// Content Moderation Utility
// Uses client-side AI to detect inappropriate content

let nsfwModel = null;
let isModelLoading = false;

// Initialize NSFW model (lazy loading)
export const initNSFWModel = async () => {
  if (nsfwModel || isModelLoading) return nsfwModel;
  
  isModelLoading = true;
  try {
    // Dynamically import nsfwjs only when needed
    const nsfwjs = await import('@tensorflow/tfjs');
    const nsfw = await import('nsfwjs');
    
    nsfwModel = await nsfw.load();
    console.log('✅ NSFW detection model loaded');
    return nsfwModel;
  } catch (error) {
    console.error('Failed to load NSFW model:', error);
    return null;
  } finally {
    isModelLoading = false;
  }
};

// Analyze video frame for inappropriate content
export const analyzeFrame = async (videoElement) => {
  try {
    if (!nsfwModel) {
      await initNSFWModel();
    }
    
    if (!nsfwModel) {
      console.warn('NSFW model not available');
      return { safe: true, confidence: 0 };
    }

    const predictions = await nsfwModel.classify(videoElement);
    
    // Categories: Neutral, Drawing, Hentai, Porn, Sexy
    const inappropriate = predictions.filter(p => 
      ['Hentai', 'Porn'].includes(p.className) && p.probability > 0.6
    );
    
    const suspicious = predictions.filter(p => 
      p.className === 'Sexy' && p.probability > 0.7
    );

    const isInappropriate = inappropriate.length > 0;
    const isSuspicious = suspicious.length > 0;
    
    return {
      safe: !isInappropriate && !isSuspicious,
      inappropriate: isInappropriate,
      suspicious: isSuspicious,
      predictions,
      highestRisk: predictions.reduce((max, p) => 
        p.probability > max.probability ? p : max
      ),
    };
  } catch (error) {
    console.error('Frame analysis error:', error);
    return { safe: true, confidence: 0, error: error.message };
  }
};

// Capture frame from video element
export const captureVideoFrame = (videoElement) => {
  try {
    const canvas = document.createElement('canvas');
    canvas.width = videoElement.videoWidth;
    canvas.height = videoElement.videoHeight;
    
    const ctx = canvas.getContext('2d');
    ctx.drawImage(videoElement, 0, 0);
    
    return canvas.toDataURL('image/jpeg', 0.8);
  } catch (error) {
    console.error('Frame capture error:', error);
    return null;
  }
};

// Auto-moderation configuration
export const MODERATION_CONFIG = {
  enabled: true,
  checkInterval: 10000, // Check every 10 seconds
  confidenceThreshold: 0.6, // 60% confidence to flag
  autoReportThreshold: 0.8, // 80% confidence to auto-report
  maxViolations: 2, // Auto-disconnect after 2 violations
};

// Format AI analysis for report
export const formatAIReport = (analysis) => {
  const { highestRisk, predictions } = analysis;
  
  let reason = 'Inappropriate Content Detected';
  let description = `AI detected potentially inappropriate content:\n\n`;
  
  if (highestRisk) {
    description += `Primary Detection: ${highestRisk.className} (${(highestRisk.probability * 100).toFixed(1)}% confidence)\n\n`;
  }
  
  description += 'Full Analysis:\n';
  predictions.forEach(p => {
    description += `- ${p.className}: ${(p.probability * 100).toFixed(1)}%\n`;
  });
  
  description += '\n⚠️ This report was automatically generated by AI content moderation.';
  
  return { reason, description };
};
